/* vxbFdtUsbSynopsysHcd_rpi_3.c - VxBus Gen2 USB SYNOPSYSHCD FDT Driver
 * Inferface
 */

/*
 * Copyright (c) 2019 Wind River Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1) Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2) Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3) Neither the name of Wind River Systems nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
modification history
--------------------
20may19,hkl  created (F11409)
*/

/*
DESCRIPTION

This file contains the initialization and uninitialization routines
provided by the Synopsys USB Host Controller Driver.

EXTERNAL INTERFACE
The driver provides a vxBus gen2 external interface. Initialization 
methods provided by vxbFdtUsbSynopsysHcdDrv register the driver with 
VxBus. The BSP's dts entry must specify the following parameters:

\is

\i compatible:
Specify the programming model for the device. It should be set to 
"brcm,bcm2708-usb" and is used by vxbus GEN2 for device driver selection.

\i reg:
Specify the base address where the USB controller registers are mapped 
into the host's address space. All register offsets are computed 
relative to this address.

\i interrupts:
Specify interrupt vector of the interrupts that are generated by this 
device.

\i interrupt-parent:
This property is available to define an interrupt parent. if it is 
missing from a device, it's interrupt parent is assumed to be its 
device tree parent.

\i rhnum-ports:
Specify the count of the Root Hub ports.

\i dma-channels:
Specify the count of available DMA channels.

\i devno:
Specify the USB OTG controller number.

\i usb-phy:
Specify the USB PHY device.

\ie

To add this driver to the vxWorks image, add the following component to 
 the kernel configuration.

\cs
vxprj vip component add INCLUDE_SYNOPSYSHCI_RPI_3
\ce

*/

/* includes */

#include <vxWorks.h>
#include <hwif/buslib/vxbFdtLib.h>
#include "vxbUsbSynopsysHcd_rpi_3.h"

/* externs */

IMPORT STATUS usbSynopsysHcdAttach
    (
    struct vxbDev * pDev,
    USB_SYNOPSYSHCD_CFG *  pCfg
    );
IMPORT STATUS usbSynopsysHcdDetach
    (
    struct vxbDev * pDev 
    );
IMPORT STATUS usbSynopsysHcdShutdown
    (
    struct vxbDev * pDev 
    );
IMPORT USB_PHY_TYPE vxbFdtUsbPhyTypeGet
    (
    struct vxbDev * pDev
    );
IMPORT void * vxbFdtUsbPhyDevGet
    (
    struct vxbDev * pDev,
    char *          pPropName
    );

/* locals */

LOCAL STATUS fdtUsbSynopsysHcdProbe
    (
    struct vxbDev * pDev
    );

LOCAL STATUS fdtUsbSynopsysHcdAttach
    (
    struct vxbDev * pDev
    );

LOCAL STATUS fdtUsbSynopsysHcdDetach
    (
    struct vxbDev * pDev
    );

LOCAL STATUS fdtUsbSynopsysHcdShutdown
    (
    struct vxbDev * pDev
    );

LOCAL int usbSynopsysHcdGetDeviceNumber
    (
    VXB_DEV_ID pDev
    );

LOCAL STATUS usbSynopsysOtgSwitchRole
    (
    VXB_DEV_ID           pDev,
    USB_SYNOPSYSOTG_MODE mode
    );
VXB_DEVMETHOD_DEF (vxbOtgSwitchRole,"OTG role switching")

LOCAL STATUS usbSynopsysOtgGetRole
    (
    VXB_DEV_ID           pDev,
    USB_SYNOPSYSOTG_MODE *mode
    );
VXB_DEVMETHOD_DEF (vxbOtgGetRole,"OTG get current role")

LOCAL VXB_DRV_METHOD fdtUsbSynopsysHcdMethodList[] =
    {
    /* DEVICE API */
    { VXB_DEVMETHOD_CALL(vxbDevProbe), fdtUsbSynopsysHcdProbe },
    { VXB_DEVMETHOD_CALL(vxbDevAttach), fdtUsbSynopsysHcdAttach },
    { VXB_DEVMETHOD_CALL(vxbDevDetach), fdtUsbSynopsysHcdDetach },
    { VXB_DEVMETHOD_CALL(vxbDevShutdown), fdtUsbSynopsysHcdShutdown },
    { VXB_DEVMETHOD_CALL(vxbOtgSwitchRole), usbSynopsysOtgSwitchRole },
    { VXB_DEVMETHOD_CALL(vxbOtgGetRole), usbSynopsysOtgGetRole },
    { 0, NULL }
    };

LOCAL USB_SYNOPSYSHCD_CFG g_synopsysHcdRpi3DefaultCfg =
    {
    NULL,                  /* pPerInitHook */
    NULL,                  /* pPostResetHook */
    NULL,                  /* pUnInitHook */
    NULL,                  /* pDescSwap */
    NULL,                  /* pUsbSwap */
    NULL,                  /* pRegSwap */
    0,                     /* uPhyBaseAddr */
    0,                     /* uPlatformType */
    0,                     /* uRegOffset */
    FALSE,                 /* bFixupPortNumber */
    FALSE,                 /* bDescBigEndian */
    FALSE,                 /* bRegBigEndian */
    FALSE,                 /* bIntEachTD */
    FALSE,                 /* bHasCompanion */
    0,                     /* uDevClass */
    NULL,                  /* pPhyDev */
    USB_PHY_TYPE_UTMI,     /* phyType */
    NULL                   /* pExtData */
    };

/* USB SYNOPSYSHCD FDT driver */

VXB_DRV vxbFdtUsbSynopsysHcdRpi3Drv =
    {
    { NULL } ,
    "rpi3-usb-otg",                     /* Name */
    "RPI3 USB SYNOPSYSHCD FDT Driver",  /* Description */
    VXB_BUSID_FDT,                      /* Class */
    0,                                  /* Flags */
    0,                                  /* Reference count */
    fdtUsbSynopsysHcdMethodList         /* Method table */
    };

LOCAL const VXB_FDT_DEV_MATCH_ENTRY fdtUsbSynopsysHcdMatchList[] =
    {
        {
        "brcm,bcm2708-usb",                     /* compatible */
        (void *)&g_synopsysHcdRpi3DefaultCfg    /* data */
        },
        {} /* Empty terminated list */
    };

LOCAL USB_SYNOPSYSOTG_MODE g_usbOtgMode[USB_MAX_SYNOPSYSHCI_COUNT];

/******************************************************************************
*
* fdtUsbSynopsysHcdProbe - probe for a valid USB SYNOPSYSHCD controller hardware
*
* This routine is used to probe for a valid USB SYNOPSYSHCD controller hardware.
*
* RETURNS: OK with a valid usb SYNOPSYSHCD controller, or ERROR otherwise.
*/

LOCAL STATUS fdtUsbSynopsysHcdProbe
    (
    struct vxbDev * pDev 
    )
    {
    return vxbFdtDevMatch (pDev, fdtUsbSynopsysHcdMatchList, NULL);
    }

/******************************************************************************
*
* fdtUsbSynopsysHcdAttach - attach the device to the SYNOPSYSHCD driver
*
* This routine is used to attach the SYNOPSYSHCD controller to the SYNOPSYSHCD driver.
*
* RETURNS: OK if success, or ERROR when failure.
*
*/

LOCAL STATUS fdtUsbSynopsysHcdAttach
    (
    struct vxbDev * pDev /* Device information */
    )
    {
    STATUS                    status   = ERROR;
    VXB_FDT_DEV_MATCH_ENTRY * pMatch   = NULL;
    VXB_FDT_DEV             * pFdtDev  = NULL;
    USB_SYNOPSYSHCD_CFG       ehcdCfg;
    void                    * prop     = NULL;
    int                       len      = 0;
    int                       devno    = -1;

    pFdtDev = (VXB_FDT_DEV *)vxbFdtDevGet (pDev);
    if (pFdtDev == NULL)
        {
        return ERROR;
        }

    /* Get OTG controller number */

    prop = (void *)vxFdtPropGet (pFdtDev->offset, "devno", &len);
    if (prop == NULL)
        return ERROR;

    devno = (UINT8)vxFdt32ToCpu(*((UINT32*)prop));
    if ((devno < 0) || (devno > (USB_MAX_SYNOPSYSHCI_COUNT - 1)))
        return ERROR;

    /* check the role */
    if (g_usbOtgMode[devno] == USB_SYNOPSYSOTG_MODE_NONE)
        {
        prop = (void *)vxFdtPropGet (pFdtDev->offset, "default-mode", &len);
        if (prop != NULL)
            {
            if (strcmp((const char*)prop, "host") == 0)
                {
                g_usbOtgMode[devno] = USB_SYNOPSYSOTG_MODE_HOST;
                }
            else if (strcmp((const char*)prop, "device") == 0)
                {
                g_usbOtgMode[devno] = USB_SYNOPSYSOTG_MODE_DEVICE;
                }
            else
                {
                return ERROR;
                }
            }
        else
            {
            g_usbOtgMode[devno] = USB_SYNOPSYSOTG_MODE_HOST;
            }
        }
    
    if (g_usbOtgMode[devno] == USB_SYNOPSYSOTG_MODE_DEVICE)
        {
        /* device mode */
        return ERROR;
        }

    /* host mode */

    /* 
     * Check if the device in the supported list again
     * to get the configuration parameters
     */

    /* Check if the new device in the supported list */
    
    status = vxbFdtDevMatch (pDev, fdtUsbSynopsysHcdMatchList, &pMatch);

    if ((status == ERROR) ||
        (NULL == pMatch))
        {
        return ERROR;
        }

    pFdtDev = (VXB_FDT_DEV *)vxbFdtDevGet (pDev);
    if (pFdtDev == NULL)
        {
        return ERROR;
        }

    /* Copy the configuration data */
    
    memcpy((void *)&ehcdCfg, pMatch->data, sizeof (USB_SYNOPSYSHCD_CFG));

    if (strncmp (pMatch->compatible, "Altera_cyclone5,synopsysHcd", 0x20) == 0)
        {
        ehcdCfg.pPhyDev = vxbFdtUsbPhyDevGet(pDev, "Altera_cyclone5,usbphy");
        }
    else
        {
        ehcdCfg.pPhyDev = vxbFdtUsbPhyDevGet(pDev, "usb-phy");
        }

    ehcdCfg.uDevClass = VXB_BUSID_FDT;
    
    /* 
     * When there is no USB PHY Device pointer, check if the PHY
     * type defined in SYNOPSYSHCD host controller's DTS, with "phy_type"
     */

    if (NULL != ehcdCfg.pPhyDev)
        {
        ehcdCfg.phyType = vxbUsbPhyTypeGet(ehcdCfg.pPhyDev);
        }
    else
        {
        ehcdCfg.phyType = vxbFdtUsbPhyTypeGet(pDev);
        }

    /* Get root hub port count */

    prop = (void *)vxFdtPropGet (pFdtDev->offset, "rhnum-ports", &len);
    if (prop != NULL)
        ehcdCfg.usbNumPorts = (UINT8)vxFdt32ToCpu(*((UINT32*)prop));

    /* Get host channel count */

    prop = (void *)vxFdtPropGet (pFdtDev->offset, "dma-channels", &len);
    if (prop != NULL)
        ehcdCfg.hostNumDmaChannels = (UINT8)vxFdt32ToCpu(*((UINT32*)prop));

    /* Get platform type */

    prop = (void *)vxFdtPropGet (pFdtDev->offset, "platform-type", &len);
    if (prop != NULL)
        ehcdCfg.uPlatformType = (UINT8)vxFdt32ToCpu(*((UINT32*)prop));

    ehcdCfg.usbDevNum = (UINT8)devno;
    
    /*
     * USB is little endian, if CPU is big endian, we need this swap!
     * This is to swap data such as the PortStatus and PortStatusChange
     * to/from CPU endian to set or clear any bit; And when reporting
     * to the USBD (by URB callback), swap into Little Endian so that
     * it conforms to USB requirement.
     */

#if (_BYTE_ORDER == _BIG_ENDIAN)
     ehcdCfg.pUsbSwap = vxbSwap32;
#endif

    /*
     * Normal SYNOPSYSHCD data structures are little endian, if the CPU is
     * big endian and it implements these data structures to be little
     * endian, then we need this swap; But if the CPU is big endian
     * and it implements these data structures to be also big endian,
     * then we do not need this swap (which is the case for all
     * MPC5121E SOCs)! In short, if the descriptor endian format is
     * different with CPU endian format, we need this swap!
     */

#if (_BYTE_ORDER == _BIG_ENDIAN)
    /* CPU BE, but DESC LE */

    if (ehcdCfg.bDescBigEndian == FALSE)
        {
        ehcdCfg.pDescSwap = vxbSwap32;
        }
#else
    /* CPU LE, but DESC BE */

    if (ehcdCfg.bDescBigEndian == TRUE)
        {
        ehcdCfg.pDescSwap = vxbSwap32;
        }
#endif

    /*
     * Normal SYNOPSYSHCD is little endian, if the CPU is big endian and
     * it implements SYNOPSYSHCD registers in little endian, then we need
     * this swap (as the case for MPC5121E silicon REV1.5); But if
     * the CPU is big endian, and it implements SYNOPSYSHCD registers in
     * big endian, then we do not need this swap! In short, if the
     * register endian format is different with CPU endian format,
     * we need this swap!
     */

#if (_BYTE_ORDER == _BIG_ENDIAN)
    /* CPU BE, but REG LE */

    if (ehcdCfg.bRegBigEndian == FALSE)
        {
        ehcdCfg.pRegSwap = vxbSwap32;
        }
#else
    /* CPU LE, but REG BE */

    if (ehcdCfg.bRegBigEndian == TRUE)
        {
        ehcdCfg.pRegSwap = vxbSwap32;
        }
#endif

    /* Update the vxBus read-write handle */

    if (ERROR == usbSynopsysHcdAttach(pDev, &ehcdCfg))
        {
        USB_SHCD_ERR("usbSynopsysHcdAttach fail\n", 1, 2, 3, 4, 5, 6);
        return ERROR;
        }

    return OK;
    }

/******************************************************************************
*
* fdtUsbSynopsysHcdDetach - detach the device to the SYNOPSYSHCD driver
*
* This routine is used to detach the SYNOPSYSHCD controller to the SYNOPSYSHCD driver.
*
* RETURNS: OK if success, or ERROR when failure.
*
*/

LOCAL STATUS fdtUsbSynopsysHcdDetach
    (
    struct vxbDev * pDev /* Device information */
    )
    {
    STATUS status = ERROR;
    int    devno  = usbSynopsysHcdGetDeviceNumber (pDev);

    if (devno < 0)
        return status;

    switch (g_usbOtgMode[devno])
        {
        case USB_SYNOPSYSOTG_MODE_HOST:
            status = usbSynopsysHcdDetach (pDev);
            break;
        case USB_SYNOPSYSOTG_MODE_DEVICE:
            status = ERROR;
            break;
        default:
            break;
        }

    return status;
    }

/******************************************************************************
*
* fdtUsbSynopsysHcdShutdown - shutdown the driver
*
* This routine shutdowns the driver. It is called on a reboot.
*
* RETURNS: OK if success, or ERROR when failure.
*
*/

LOCAL STATUS fdtUsbSynopsysHcdShutdown
    (
    struct vxbDev * pDev
    )
    {
    STATUS status = ERROR;
    int    devno  = usbSynopsysHcdGetDeviceNumber(pDev);

    if (devno < 0)
        return status;
    
    switch (g_usbOtgMode[devno])
        {
        case USB_SYNOPSYSOTG_MODE_HOST:
            status = usbSynopsysHcdShutdown (pDev);
            break;
        case USB_SYNOPSYSOTG_MODE_DEVICE:
            status = ERROR;
            break;
        default:
            break;
        }

    return status;
    }

/******************************************************************************
*
* usbSynopsysHcdGetDeviceNumber - get OTG controller number
*
* This routine returns the device number of the OTG controller
*
* RETURNS: device number or -1
*
*/

LOCAL int usbSynopsysHcdGetDeviceNumber
    (
    VXB_DEV_ID pDev
    )
    {
    VXB_FDT_DEV * pFdtDev  = NULL;
    void        * prop     = NULL;
    int           devno    = -1;
    int           len      = 0;

    if (pDev == NULL)
        goto exit;

    pFdtDev = (VXB_FDT_DEV *)vxbFdtDevGet (pDev);
    if (pFdtDev == NULL)
        goto exit;

    /* Get OTG controller number */
    prop = (void *)vxFdtPropGet (pFdtDev->offset, "devno", &len);
    if (prop == NULL)
        goto exit;

    devno = (UINT8)vxFdt32ToCpu(*((UINT32*)prop));

    if ((devno < 0) || (devno > (USB_MAX_SYNOPSYSHCI_COUNT - 1)))
        devno = -1;

exit:
    return devno;
    }

/******************************************************************************
*
* usbSynopsysOtgSwitchRole - switch OTG role
*
* This routine switches OTG controller's role, host or device
* 
* NOTE: Detach the vxBus OTG driver first before switching the role. 
*       Then attach the driver again after calling this routine.
*
* RETURNS: OK or ERROR
*
*/

LOCAL STATUS usbSynopsysOtgSwitchRole
    (
    VXB_DEV_ID           pDev,
    USB_SYNOPSYSOTG_MODE mode
    )
    {
    STATUS status = ERROR;
    int    devno  = -1;

    if (pDev == NULL)
        goto exit;

    if ((mode != USB_SYNOPSYSOTG_MODE_HOST) &&
        (mode != USB_SYNOPSYSOTG_MODE_DEVICE))
        goto exit;

    if (vxbDevSoftcGet (pDev) != NULL)
        goto exit;

    devno = usbSynopsysHcdGetDeviceNumber (pDev);
    if (devno < 0)
        goto exit;

    g_usbOtgMode[devno] = mode;

    status = OK;
exit:
    return status;    
    }

/******************************************************************************
*
* usbSynopsysOtgGetRole - get current OTG role
*
* This routine gets OTG controller's current role, host or device
* 
* RETURNS: OK or ERROR
*
*/

LOCAL STATUS usbSynopsysOtgGetRole
    (
    VXB_DEV_ID           pDev,
    USB_SYNOPSYSOTG_MODE *mode
    )
    {
    STATUS status = ERROR;
    int    devno  = -1;

    if ((pDev == NULL) || (mode == NULL))
        goto exit;

    devno = usbSynopsysHcdGetDeviceNumber (pDev);
    if (devno < 0)
        goto exit;

    *mode = g_usbOtgMode[devno];

    status = OK;
exit:
    return status;
    }

VXB_DRV_DEF(vxbFdtUsbSynopsysHcdRpi3Drv)

